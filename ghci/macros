
:{
:def bind \varcmd -> case break Data.Char.isSpace varcmd of
          (var,_:cmd) -> return $ unlines
             [":set -fno-print-bind-result" 
             ,"tmp <- System.Directory.getTemporaryDirectory"
             ,"(f,h) <- System.IO.openTempFile tmp \"ghci\""
             ,"sto <- GHC.IO.Handle.hDuplicate System.IO.stdout"
             ,"GHC.IO.Handle.hDuplicateTo h System.IO.stdout"
             ,"System.IO.hClose h"
             ,cmd
             ,"GHC.IO.Handle.hDuplicateTo sto System.IO.stdout"
             ,"let readFileNow f = readFile f >>= \\t->length t `seq` return t"
             ,var++" <- fmap (reverse Prelude.. drop 1 Prelude.. reverse) (readFileNow f)"
             ,"System.Directory.removeFile f"]
          _ -> return "putStrLn \"usage: :bind <var> <cmd>\""
:}

:{
let escape :: String -> String -> (String, String)
    escape hd ('\\':'|':tl) = escape ('|':hd) tl
    escape hd ('|':tl) = (Data.List.intercalate "\\\\n" Prelude.. lines Prelude.. reverse Prelude.. drop 1 $ hd, dropWhile Data.Char.isSpace Prelude.. drop 1 $ tl)
    escape hd (t:tl) = escape (t:hd) tl
:}
:{
:def sh \varcmd -> let (ghci, bash) = escape "" varcmd
                   in return $ unlines
                     [":bind ghci "++ghci
                     ,":cmd return $ \":!echo \"++show ghci++\" | "++bash++"\""]
:}

:{
:def grep \cmd -> case break Data.Char.isSpace cmd of
          (glob,_:cmd) -> return $ ":sh "++cmd++" | grep "++glob
:}

:{
:def grub \cmd -> if Data.Char.isUpper . head $ cmd
                  then case break Data.Char.isSpace cmd of
                      (mod, _:glob) -> return $ ":sh :browse "++mod++" | grep "++glob
                  else return $ ":sh :browse | grep "++cmd
:}
